4번
#include <stdio.h>

//int box[100][100] = { 0, }; 박스를 출력할 것이 아니면 굳이 선언할 필요 없음.

int main(void){
    int N = 9; //가로 길이(막대의 갯수. 돌리고 나면 박스의 세로 길이가 됨)
    int M = 8; //세로 길이(막대의 최대 길이. 돌리고 나면 박스의 가로 길이가 됨)

    int input[9] = {7,4,2,0,0,6,0,7,0};  // 여기서 배열의 길이 9는 N(막대의 개수)의 크기와 같아야함 (하드 코딩)

    int under; //내 오른쪽(아래)에 나보다 같거나 큰 박스가 몇개가 있는지 저장하는 변수
    int max = 0; //떨어지는 최대값을 저장

    //input 배열에 입력. 어차피 돌릴거 90도 돌아간 상태로 바로 저장합니다. 사실 이 코드는 아예 없어도 됩니다.
    //어차피 입력값만 가지고도 계산이 가능하기 때문에.
    // for(int i = 0 ; i < 9 ; i++){ // 여기 9도 N. (하드코딩)
    //     for (int j = 0 ; j < input[i] ; j++){ //예를 들어 input[0]이 7이면 높이가 7이라는 말이니까 1을 1개 채움.
    //         box[i][j] = 1;
    //     }
    // }

    for(int i = 0 ; i < N-1 ; i++){ //박스의 세로(막대의 개수)의 길이 -1만큼 확인(마지막 막대는 어차피 떨어지는 거리가 0임)
        if(input[i] != 0){ // 막대의 길이가 0이 아닐때만 아래 코드 실행
            under = 0;
            for (int j = i+1; j <N; j++ ){
                if(input[i] <= input[j]){ //검사중인 막대보다 크거나 같은 막대가 있으면 아래에 블럭이 더 있는 것이므로 under에 +1
                    under++;
                }
            }
            if( max < N - i - under - 1){
                max = N - i - under - 1; // 떨어지는칸 = 총 높이 - 인덱스 - 내 아래 있는 블럭 개수 - 1
            }
        }
    }

    printf("%d\n", max);


    //디버깅용. box 출력하는 함수
    // for(int i = 0 ; i < N ; i++){
    //     for(int j = 0 ; j < M ; j++){
    //         printf("%d ", box[i][j]);
    //     }
    //     printf("\n");
    // }


}
